from fastapi import FastAPI, HTTPException, status
from context_manager import lifespan
from database import session_dependency
from sqlmodel import select
from models import Book, BookReadModel, BookUpdateModel, BookCreateModel

# FastAPI app
app = FastAPI(
    title="Book Management API",
    description="A modern API for managing books using SQLModel and FastAPI.",
    lifespan=lifespan,  # Use lifespan for async startup/shutdown
)



# Create a new book.
# The ID is auto-generated by the database.
# Check for existing book with the same title

@app.post("/book/", response_model=BookReadModel, status_code=status.HTTP_201_CREATED)
async def create_a_book(book: BookCreateModel, session: session_dependency):
    book = Book.model_validate(book)

    existing_book = await session.get(Book, book.id)
    if existing_book:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Book with id {book._id} already exists.",
        )

    session.add(book)
    await session.commit()
    await session.refresh(book)
    return book


# Get all books with limit and offset as a default query parameter.
@app.get("/books/", response_model=list[BookReadModel])
async def get_all_books(session: session_dependency, offset: int = 0, limit: int = 5):
    statement = select(Book).offset(offset).limit(limit)
    result = await session.execute(statement)
    books = result.scalars().all()
    return books


# Get a Book.
@app.get("/books/{book_id}", response_model=BookReadModel)
async def get_a_book(book_id: int, session: session_dependency):
    book = await session.get(Book, book_id)
    if not book:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Book with id {book_id} not found",
        )
    return book


# Update a Book.
@app.patch("/books/{book_id}", response_model=BookReadModel)
async def update_a_book(
    book_id: int, book: BookUpdateModel, session: session_dependency
):
    db_book = await session.get(Book, book_id)
    if not db_book:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Book with id {book_id} not found",
        )

    new_book = book.model_dump(exclude_unset=True)
    db_book = db_book.sqlmodel_update(new_book)

    session.add(db_book)
    await session.commit()
    await session.refresh(db_book)
    return db_book


# Delete a Book.
@app.delete("/books/{book_id}")
async def delete_a_book(book_id: int, session: session_dependency):
    book = await session.get(Book, book_id)
    if not book:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Book with id {book_id} not found",
        )
    await session.delete(book)
    await session.commit()
    return {"message": f"The book with id {book_id} is deleted successfully"}
