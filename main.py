from fastapi import FastAPI, HTTPException, status
from context_manager import lifespan
from database import session_dependency
from sqlmodel import select
from models import Book, BookReadModel, BookUpdateModel, BookCreateModel

# FastAPI app
app = FastAPI(
    title="Book Management API",
    description="A modern API for managing books using SQLModel and FastAPI.",
    lifespan=lifespan,  # Use lifespan for async startup/shutdown
)

# Create a new book.
# ID is auto-generated by the database.
# Check if a book has the same id.

@app.post("/book/", response_model=BookReadModel, status_code=status.HTTP_201_CREATED)
async def create_a_book(book: BookCreateModel, session: session_dependency):
    book = Book.model_validate(book)
    session.add(book)
    await session.commit()
    await session.refresh(book)
    return book


# Get all books with limit and offset as a default query parameter.
# We can use Query to set the range for the offset and limit query parameters.
@app.get("/books/", response_model=list[BookReadModel])
async def get_all_books(
    session: session_dependency,
    offset: Annotated[int, Query(min_length=0)] = 0,
    limit: Annotated[int, Query(max_length=50)] = 5,
):
    statement = select(Book).offset(offset).limit(limit)
    result = await session.execute(statement)
    books = result.scalars().all()
    return books


# Get a Book.
@app.get("/books/{book_id}", response_model=BookReadModel)
async def get_a_book(book_id: int, session: session_dependency):
    book = await session.get(Book, book_id)
    if not book:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Book with id {book_id} not found",
        )
    return book


# Update a Book.
@app.patch("/books/{book_id}", response_model=BookReadModel)
async def update_a_book(
    book_id: int, new_book: BookUpdateModel, session: session_dependency
):
    db_book = await session.get(Book, book_id)
    if not db_book:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Book with id {book_id} not found",
        )

    new_book_dict = new_book.model_dump(exclude_unset=True)
    updated_book = db_book.sqlmodel_update(new_book_dict)

    session.add(updated_book)
    await session.commit()
    await session.refresh(updated_book)
    return updated_book


# Delete a Book.
@app.delete("/books/{book_id}")
async def delete_a_book(book_id: int, session: session_dependency):
    book = await session.get(Book, book_id)
    if not book:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Book with id {book_id} not found",
        )
    await session.delete(book)
    await session.commit()
    return {"message": f"The book with id {book_id} is deleted successfully"}
